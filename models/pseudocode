# Step 1: Apply diffusion process to input trajectories
diffused_output, t = ApplyDiffusion(input_future_trajectories)

# Step 2: Pass the diffused output through a graph neural network
gnn_output = GraphNeuralNetwork(diffused_output)

# Step 3: Get condition c based on the history
condition_c = GraphNeuralNetwork(input_history_trajectories)

# Step 4: Positional Encoding of the timestep
encoded_timestep = EncodeTimestep(t)

# Step 5: Concatenate gnn_output, condition_c, and encoded_timestep
concatenated_output = Concatenate(gnn_output, condition_c, encoded_timestep)

# Step 6: Pass the concatenated output through a feedforward MLP network
logits_next_edges = FeedforwardMLP(concatenated_output)
loss = CrossEntropyLoss(logits_next_edges, ground_truth_next_edges)

